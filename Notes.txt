equals() contract!!

Compile-time constant:
final variables that must be declared and initialized in the same line.
Switch only accepts Compile-time constant; The values must be: integers, except long, them wrappers, String and enum

Doesn't matter where case labels are placed.. Them acts like doors..
Case labels can't be duplicated

Switch discarts decimals values defining constants.

Watch out for the annonimous block inside if's

Labeled statements:
■ You can add labels to a code block defined using braces, {}, all looping statements (for, enhanced forloop, while, do-while), conditional constructs (if
and switchstatements), expressions and assignments, returnstatements, try
blocks, and throwsstatements.
■ You can’t add labels to declarations of variables.
■ You can use a labeled breakstatement to exit an outer loop. 
■ You can use a labeled continuestatement to skip the iteration of the outer loop.

NOTE When you try to access an invalid array position, ArrayIndexOutOfBoundsException is thrown. When you try to access an invalid ArrayList position, IndexOutOfBoundsExceptionis thrown.

Exception hierarchy!!!! ****

ExceptionInInitializerError can  be  caused  by  an  object  of
RuntimeExceptiononly. It can’t occur as the result of an error or checked
exception thrown by the staticinitialization block.

Don’t  confuse  the  exception  thrown  by Class.forName(),  used  to
load  the  class,  and NoClassDefFoundErrorthrown by the JVM. Class.forName()throws ClassNotFoundException.

Narrowing -> Lose of information by casting
Empty statement -> consists of a single semicolon. When executed, it does nothing. It is commonly used as a place holder indicating that nothing is to be done

INTEGER DATA TYPES -> include byte, char, short, and int. Any of these data types can be used with an integer switch statement. The data type longis not allowed

BigDecimal provides better accuracy for decimal points.

By using the strictfpkeyword, all calculations will strictly abide by the IEEE standard

Java does not support two-dimensional arrays in the strictest sense. In reality they are arrays of arrays.

RAGGED ARRAYS -> the rows do not necessarily have to be the same size.

To compare two arrays correctly we need to use the Arraysclass' equals or deepEqualsmethods.

Shallow copy: Refers to when only the reference values are copied. After the copy operation, the original object has not been duplicated.
In a deep copy, the reference to the object is not copied. Instead, a new copy of the object is created.

Comparator Object??

While ArrayListis a powerful class, arrays should still be used if:
•  There is a known number of elements
•  It has a small fixed upper bound
•  Primitive data types are needed for efficiency
•  No elements need to be inserted

The comma opperator -> It is used to separate the parts of the initial-expression and the end-loop operation sections of the for loop.

The equals method is executed against the string literal and the command is used as its argument. This approach avoids
NullPointerException that will result if the command contains a null value. As the string literals are never null, this exception will never occur.

A label consists of a name followed by a colon (":")

Infinite loops --> The moral of the story is, "Be careful with loops". Infinite loops can be both a
useful construct for solving some problems and a problematic construct when used unintentionally.

Multiplying by 1.0f is necessary to avoid integer division:
	average = total / (age.length * 1.0f);

Pitfall with decimals when comparing -> The number 0.1 cannot be stored precisely in base two in the same way that the
decimal equivalent of the fraction 1/3 cannot be represented exactly (0.333333...). The same goes to 0.1 and 0.10000

There are four uses of the this keyword:
•	 Performing constructor chaining
•	 Accessing instance variables
•	 Passing the current object to a method
•	 Returning the current object from a method

The parameters will have "precedence" over the instance variables.

Another approach is to declare the parameter as a constant using the final keyword, as shown in the following code snippet. When we take this approach, a syntax error is generated because we are trying to modify the parameter.

•	 Argument: This is the variable being passed
•	 Parameter: This is the element defined within the method's signature

Java do passing by value: When a method is called, a copy of the argument is assigned to the parameter.

When a primitive data type is passed, he original data is not changed.
When a reference variable is passed, we have two references to the same object; We can modify the object using either reference variable

Variable number of args:

•	 The variable number of parameters must all be the same type
•	 They are treated as an array within the method
•	 They must be the last parameter of the method

To create an immutable object:

•	 Make the class final which means that it cannot be extended (covered in
the Using the final keyword with classes section in Chapter 7, Inheritance and
Polymorphism)
•	 Keep the fields of the class private and ideally final
•	 Do not provide any methods that modify the state of the object, that is do not
provide setter or similar methods
•	 Do not allow mutable field objects to be changed

As a general rule, always add a default constructor to a class. This is particularly important when the class is a base class.

Initializing variables members:

Instance variable initializers
Initialization block (Before the constructor)
Constructor

The order of initializing: 

1. The zeroing of fields performed when the object is instantiated
2. The initialization of final and static variables
3. The assignment of instance variables initializers
4. The execution of initialization blocks
5. The code within a constructor

POLYMORPHISM -> is the result of overriding methods of a base class.

/*
##################################################
A significant part of becoming a skilled Java programmer is 
learning to find, understand, and use those classes found in 
libraries relevant to your application's domain.
##################################################
*/

OVERLOADING VS. OVERRIDING

Characteristic 	Overloading 	Overriding
Method name 	Same 			Same
Signature 		Different 		Same
Class 			Same class 		In a derived class

It is not possible to call a base method above the current base class. 
	super.super.toString(); //illegal

The application of the instanceof operator confirms that the Employee class is 
ultimately an object of Object. (instanceof chequea hasta lo ultimo!!)

When a new class is created it is always a good idea to override the toString, equals, and hashCode methods.

Before an object can be cloned, its class must implement the java.lang.Cloneable interface. The clone method is protected.

When we cast a derived class object to a base class reference variable, it is called upcasting. When we cast a base class object to a derived class reference variable, it is called downcasting.

Upcasting is possible because the derived object contains everything that the base class has, plus something more. Downcasting is not a good idea as the reference variable expects an object with more capabilities than is supplied. =(

The use of the private and protected keywords cannot be used with a class definition unless the class is an inner class. An inner class is a class that is declared within another class.

Checked exceptions include all exceptions derived from the Exceptionclass and are not derived from the RuntimeExceptionclass.
Unchecked exceptions are all other exceptions. They include exceptions, such as division by zero and array subscripting errors.

A general rule of thumb is to declare the exception as an unchecked exception if the client code cannot do anything to recover from the exception. Otherwise, if they can handle it, make it a checked exception.

There are three general techniques we can use when dealing with exceptions in Java:
•  Traditional tryblock
•  The new "try-with-resources" block introduced in Java 7
•  Pass the buck

finally block will not execute if the System.exit method is invoked in a try or catch block.

The general rule is always to list the "most-derived" EXCEPTIONS first. 

Keep in mind that tHE CATCH BLOCK'S PARAMETER IS IMPLICITLY FINAL. It is not possible to assign a different exception to the parameter.